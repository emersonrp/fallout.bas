10 CLEAR 2048 : RANDOM
20 GUESSES% = 4
30 GOSUB 60000: ' Populate the word list
40 WORDLENGTH% = LEN(WORDS$(1))
50 PASSWORDIDX% = RND(WORDLISTLENGTH%)
60 PASSWORD$ = WORDS$(PASSWORDIDX%)
70 DIM OUTPUTLINES$(15): ' 15 lines because the bottom one we always do dynamically
500 CLS
510 PRINT
520 PRINT "Welcome to ROBCO Industries (TM) Termlink"
530 PRINT
540 PRINT "Password Required"
550 PRINT
560 PRINT
570 PRINT
1000 REM - set up the vars representing the left and right text fields
1010 RESTORE 1010
1020 DATA " ","/","\","!","@","#","$","%","^","&","*","-","=","+",",",".",":",";"
1030 DIM GARBAGECHARS$(18)
1040 FOR I = 1 TO 18 : READ GARBAGECHARS$(I) : NEXT
1050 FOR I = 1 TO 50
1060   NEWLCHAR$ = GARBAGECHARS$(RND(18))
1070   IF NEWLCHAR$ = LASTLCHAR$ THEN 1060 ELSE LASTLCHAR$ = NEWLCHAR$
1080   LSIDE$ = LSIDE$ + NEWLCHAR$
1090 NEXT
1100 LSIDE$ = LSIDE$ + LSIDE$ + LSIDE$ + LEFT$(LSIDE$, 42)
1110 RSIDE$ = RIGHT$(LSIDE$, 32) + LEFT$(LSIDE$, 160)
1500 REM - sprinkle the words into the text fields
1510 DIM PAPOSITIONS%(WORDLISTLENGTH%,WORDLENGTH%): ' (number of words, length)
1520 RSIDEWORDCOUNT% = INT(WORDLISTLENGTH% / 2)
1530 LSIDEWORDCOUNT% = WORDLISTLENGTH% - RSIDEWORDCOUNT%
1550 LCELLLENGTH% = INT((12*16) / LSIDEWORDCOUNT%)
1560 RCELLLENGTH% = INT((12*16) / RSIDEWORDCOUNT%)
1570 DIM LSIDEPOS%(LSIDEWORDCOUNT%), RSIDEPOS%(RSIDEWORDCOUNT%)
1575 REM the math here is (move over X cells) + (middle of cell) - (center the word) + (randomize a bit)
1580 FOR I = 1 TO LSIDEWORDCOUNT%
1590   LSIDEPOS%(I) = (LCELLLENGTH% * (I-1)) + INT(LCELLLENGTH% / 2) - INT(LEN(WORDS$(I)) / 2) + (RND(7) - 4)
1600   MID$(LSIDE$, LSIDEPOS%(I), WORDLENGTH%) = WORDS$(I)
1610   GOSUB 41000
1620 NEXT I
1630 FOR I = 1 TO RSIDEWORDCOUNT%
1640   RSIDEPOS%(I) = (RCELLLENGTH% * (I-1)) + INT(RCELLLENGTH% / 2) - INT(LEN(WORDS$(I)) / 2) + (RND(7) - 4)
1650   MID$(RSIDE$, RSIDEPOS%(I), WORDLENGTH%) = WORDS$(I+LSIDEWORDCOUNT%)
1660   GOSUB 42000
1670 NEXT I
10000 REM - print the text fields at the right place
10010 TOPROW = 7
10020 GOSUB 40100
10025 HEXADDRESS = HEXADDRS!(RND(7))
10030 FOR I = 0 TO 15
10035   PALOC = (TOPROW + I) * 80
10040   PRINT @ PALOC, "0x" ; HEX$(HEXADDRESS) ; " " ; MID$(LSIDE$, I*12 + 1, 12) ; " 0x" ; HEX$(HEXADDRESS + (12*16)) ; " " ; MID$(RSIDE$, I*12 + 1, 12);
10050   HEXADDRESS = HEXADDRESS + 12
10060 NEXT I
10070 GOSUB 47000: ' print attempts remaining
10080 GOSUB 49040: ' print the prompt
20000 REM - Set up the first word as our current highlighted one.
20010 CURRWORD% = 1
20020 GOSUB 43000
21000 REM - Do the input loop and dispatch appropriately
21020 KEYIN$ = INKEY$: IF KEYIN$ = "" THEN 21020
21030 IF KEYIN$ = CHR$(10) THEN GOSUB 44000: GOSUB 45000: GOSUB 43000
21040 IF KEYIN$ = CHR$(11) THEN GOSUB 44000: GOSUB 46000: GOSUB 43000
21050 IF KEYIN$ = CHR$(13) THEN GOSUB 50000
21999 GOTO 21020
39999 END
40000 REM --- subroutine to pick a more random char from garbagechars
40010 NEWCHAR$ = GARBAGECHARS$(RND(18))
40020 IF NEWCHAR$ = LASTCHAR$ THEN 40010
40030 LASTCHAR$ = NEWCHAR$
40040 RETURN
40100 REM -- subroutine to initialize the list of hex addresses
40110 RESTORE 40130
40111 REM TODO Get a better list of these
40112 REM Don't make any of these between 0 and 4096 or HEX$ will format the screen badly
40120 DIM HEXADDRS!(7)
40130 DATA 48304,49968,64198,20992,63056,20464,62720
40140 FOR J = 1 TO 7
40150   READ HEXADDRS!(J)
40155   IF HEXADDRS!(J) > 32767 THEN HEXADDRS!(J) = HEXADDRS!(J) - 65536
40160 NEXT J
40170 RETURN
41000 REM -- subroutine to fill a two-dimensional array with lists of "print @" locations for LSIDE
41010 RAWPOS% = LSIDEPOS%(I)
41020 CURROW% = INT(RAWPOS% / 12) + 7
41030 CURCOL% = (RAWPOS% - INT(RAWPOS% / 12) * 12)
41035 IF CURCOL% = 0 THEN CURCOL% = 12: CURROW% = CURROW% - 1
41040 FOR J = 1 TO WORDLENGTH%
41050   PAPOSITIONS%(I, J) = (CURROW% * 80) + 6 + CURCOL%
41060   CURCOL% = CURCOL% + 1
41070   IF CURCOL% > 12 THEN CURCOL% = 1: CURROW% = CURROW% + 1
41080 NEXT J
41090 RETURN
42000 REM -- subroutine to fill a two-dimensional array with lists of "print @" locations for RSIDE
42010 RAWPOS% = RSIDEPOS%(I)
42020 CURROW% = INT(RAWPOS% / 12) + 7
42030 CURCOL% = (RAWPOS% - INT(RAWPOS% / 12) * 12)
42035 IF CURCOL% = 0 THEN CURCOL% = 12: CURROW% = CURROW% - 1
42040 FOR J = 1 TO WORDLENGTH%
42050   PAPOSITIONS%(I+LSIDEWORDCOUNT%, J) = (CURROW% * 80) + 26 + CURCOL%
42060   CURCOL% = CURCOL% + 1
42070   IF CURCOL% > 12 THEN CURCOL% = 1: CURROW% = CURROW% + 1
42080 NEXT J
42090 RETURN
43000 REM - highlight the word pointed to by CURRWORD% and put it lower-right
43003 PALOC = ((TOPROW + 15) * 80) + 42
43005 PRINT @ PALOC, STRING$(WORDLENGTH%, " ");
43010 FOR J = 1 TO WORDLENGTH%
43020   PRINT @ PAPOSITIONS%(CURRWORD%, J), CHR$(16) + MID$(WORDS$(CURRWORD%), J, 1) + CHR$(17);
43025   PALOC = ((TOPROW + 15) * 80) + 41 + J
43030   PRINT @ PALOC, MID$(WORDS$(CURRWORD%), J, 1);
43040 NEXT J
43050 RETURN
44000 REM - UN-highlight the word pointed to by CURRWORD%
44010 FOR J = 1 TO WORDLENGTH%
44020   PRINT @ PAPOSITIONS%(CURRWORD%, J), MID$(WORDS$(CURRWORD%), J, 1);
44030 NEXT J
44040 RETURN
45000 REM - Increment CURRWORD%, wrapping around
45010 CURRWORD% = CURRWORD% + 1
45020 IF CURRWORD% > WORDLISTLENGTH% THEN CURRWORD% = 1
45030 RETURN
46000 REM - Decrement CURRWORD%, wrapping around
46010 CURRWORD% = CURRWORD% - 1
46020 IF CURRWORD% < 1 THEN CURRWORD% = WORDLISTLENGTH%
46030 RETURN
47000 REM - print remaining-guesses line
47010 PRINT @ 400, "Attempts Remaining: ";
47020 FOR J = 1 TO 4
47025   PALOC = 417 + (J * 2)
47030   IF J <= GUESSES% THEN PRINT @ PALOC, " " ; CHR$(16) ; " " ; CHR$(17); ELSE PRINT @ PALOC, "  ";
47040 NEXT J
47050 RETURN
48000 REM - rotate / push the "stack" of right-hand output lines
48010 FOR J = 15 TO 2 STEP -1
48020   OUTPUTLINES$(J) = OUTPUTLINES$(J-1)
48030 NEXT J
48040 OUTPUTLINES$(1) = NEWLINE$
48050 RETURN
49000 REM - print the right-hand lines and the prompt
49010 FOR J = 1 TO 15
49015   PALOC = ((22 - J) * 80) + 41
49020   PRINT @ PALOC, OUTPUTLINES$(J);
49030 NEXT
49040 REM - sometimes we GOSUB into the middle, here, ir we just want to print the prompt
49050 PALOC = 22*80 + 41
49060 PRINT @ PALOC, ">" ; GUESS$;
49070 RETURN
50000 REM ===== Subroutine to process a guess
50010 IF CURRWORD% = PASSWORDIDX% THEN PRINT: PRINT"YOU WIN!": END
50020 GUESS$ = WORDS$(CURRWORD%)
50030 MATCHES% = 0
50040 FOR J = 1 TO LEN(GUESS$)
50050   IF MID$(GUESS$, J, 1) = MID$(PASSWORD$, J, 1) THEN MATCHES% = MATCHES% + 1
50060 NEXT J
50070 NEWLINE$ = ">" + GUESS$
50080 GOSUB 48000
50090 NEWLINE$ = ">Entry denied."
50100 GOSUB 48000
50110 NEWLINE$ = ">Likeness=" + RIGHT$(STR$(MATCHES%), 1)
50120 GOSUB 48000
50130 GOSUB 49000: ' print the lines
50150 GUESSES% = GUESSES% - 1
50160 GOSUB 47000: ' Decrement guesses blocks
50170 GOSUB 49040: ' repoint the cursor to bottom right
50180 IF GUESSES% = 0 THEN PRINT: PRINT"OUT OF GUESSES!  PASSWORD WAS: " ; PASSWORD$: END
59999 RETURN
60000 REM ===== IMPORT WORD LIST
60010 WORDLISTCOUNT% = 1: ' the number of word lists
60015 REM When WORDLISTCOUNT > 1, the next line should be "on rnd(WORDLISTCOUNT%) GOSUB..."
60020 GOSUB 61000: ' Set up the DATA
60030 READ WORDLISTLENGTH%
60040 DIM WORDS$(WORDLISTLENGTH%)
60050 FOR J = 1 TO WORDLISTLENGTH%
60060   READ WORDS$(J)
60070 NEXT J
60080 RETURN
61000 REM ===== WORD LISTS, each list begins with a number representing the length of the list
61010 RESTORE 61020
61020 DATA 15,TAKES,KNOWN,KICKS,STARK,BOOTS,BATON,CLEAR,CRIME,WASTE,CLOSE,SWORD,SLAVE,FARGO,MAYBE,MALES
61030 RETURN
